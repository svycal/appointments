// This file is auto-generated by @hey-api/openapi-ts

import {
  type InfiniteData,
  infiniteQueryOptions,
  queryOptions,
  type UseMutationOptions,
} from '@tanstack/react-query';

import { client } from '../client.gen';
import {
  cancelAppointment,
  confirmAppointment,
  createAccount,
  createAccountUser,
  createAppointment,
  createBlock,
  createCancellationReason,
  createClient,
  createDashboardSession,
  createProvider,
  createProviderSchedule,
  createService,
  createServiceProvider,
  deactivateProvider,
  deleteBlock,
  deleteCancellationReason,
  deleteClient,
  deleteProviderSchedule,
  deleteService,
  deleteServiceProvider,
  getAccountById,
  getAppointment,
  getBlock,
  getCancellationReason,
  getClient,
  getCurrentAccount,
  getCurrentPlatform,
  getProvider,
  getProviderSchedule,
  getService,
  listAccounts,
  listAccountUsers,
  listAppointments,
  listBlocks,
  listCancellationReasons,
  listClients,
  listProviders,
  listProviderSchedules,
  listRoles,
  listServiceProviders,
  listServices,
  listServiceSlots,
  type Options,
  rescheduleAppointment,
  updateAccount,
  updateBlock,
  updateCancellationReason,
  updateClient,
  updateProvider,
  updateProviderSchedule,
  updateService,
} from '../sdk.gen';
import type {
  CancelAppointmentData,
  CancelAppointmentError,
  CancelAppointmentResponse,
  ConfirmAppointmentData,
  ConfirmAppointmentError,
  ConfirmAppointmentResponse,
  CreateAccountData,
  CreateAccountError,
  CreateAccountResponse,
  CreateAccountUserData,
  CreateAccountUserError,
  CreateAccountUserResponse,
  CreateAppointmentData,
  CreateAppointmentError,
  CreateAppointmentResponse,
  CreateBlockData,
  CreateBlockError,
  CreateBlockResponse,
  CreateCancellationReasonData,
  CreateCancellationReasonError,
  CreateCancellationReasonResponse,
  CreateClientData,
  CreateClientError,
  CreateClientResponse,
  CreateDashboardSessionData,
  CreateDashboardSessionError,
  CreateDashboardSessionResponse,
  CreateProviderData,
  CreateProviderError,
  CreateProviderResponse,
  CreateProviderScheduleData,
  CreateProviderScheduleError,
  CreateProviderScheduleResponse,
  CreateServiceData,
  CreateServiceError,
  CreateServiceProviderData,
  CreateServiceProviderError,
  CreateServiceProviderResponse,
  CreateServiceResponse,
  DeactivateProviderData,
  DeactivateProviderError,
  DeactivateProviderResponse,
  DeleteBlockData,
  DeleteBlockError,
  DeleteBlockResponse,
  DeleteCancellationReasonData,
  DeleteCancellationReasonError,
  DeleteCancellationReasonResponse,
  DeleteClientData,
  DeleteClientError,
  DeleteClientResponse,
  DeleteProviderScheduleData,
  DeleteProviderScheduleError,
  DeleteProviderScheduleResponse,
  DeleteServiceData,
  DeleteServiceError,
  DeleteServiceProviderData,
  DeleteServiceProviderError,
  DeleteServiceProviderResponse,
  DeleteServiceResponse,
  GetAccountByIdData,
  GetAccountByIdError,
  GetAccountByIdResponse,
  GetAppointmentData,
  GetAppointmentError,
  GetAppointmentResponse,
  GetBlockData,
  GetBlockError,
  GetBlockResponse,
  GetCancellationReasonData,
  GetCancellationReasonError,
  GetCancellationReasonResponse,
  GetClientData,
  GetClientError,
  GetClientResponse,
  GetCurrentAccountData,
  GetCurrentAccountError,
  GetCurrentAccountResponse,
  GetCurrentPlatformData,
  GetCurrentPlatformError,
  GetCurrentPlatformResponse,
  GetProviderData,
  GetProviderError,
  GetProviderResponse,
  GetProviderScheduleData,
  GetProviderScheduleError,
  GetProviderScheduleResponse,
  GetServiceData,
  GetServiceError,
  GetServiceResponse,
  ListAccountsData,
  ListAccountsError,
  ListAccountsResponse,
  ListAccountUsersData,
  ListAccountUsersError,
  ListAccountUsersResponse,
  ListAppointmentsData,
  ListAppointmentsError,
  ListAppointmentsResponse,
  ListBlocksData,
  ListBlocksError,
  ListBlocksResponse,
  ListCancellationReasonsData,
  ListCancellationReasonsError,
  ListCancellationReasonsResponse,
  ListClientsData,
  ListClientsError,
  ListClientsResponse,
  ListProviderSchedulesData,
  ListProviderSchedulesError,
  ListProviderSchedulesResponse,
  ListProvidersData,
  ListProvidersError,
  ListProvidersResponse,
  ListRolesData,
  ListRolesError,
  ListRolesResponse,
  ListServiceProvidersData,
  ListServiceProvidersError,
  ListServiceProvidersResponse,
  ListServicesData,
  ListServicesError,
  ListServiceSlotsData,
  ListServiceSlotsError,
  ListServiceSlotsResponse,
  ListServicesResponse,
  RescheduleAppointmentData,
  RescheduleAppointmentError,
  RescheduleAppointmentResponse,
  UpdateAccountData,
  UpdateAccountError,
  UpdateAccountResponse,
  UpdateBlockData,
  UpdateBlockError,
  UpdateBlockResponse,
  UpdateCancellationReasonData,
  UpdateCancellationReasonError,
  UpdateCancellationReasonResponse,
  UpdateClientData,
  UpdateClientError,
  UpdateClientResponse,
  UpdateProviderData,
  UpdateProviderError,
  UpdateProviderResponse,
  UpdateProviderScheduleData,
  UpdateProviderScheduleError,
  UpdateProviderScheduleResponse,
  UpdateServiceData,
  UpdateServiceError,
  UpdateServiceResponse,
} from '../types.gen';

export type QueryKey<TOptions extends Options> = [
  Pick<TOptions, 'baseUrl' | 'body' | 'headers' | 'path' | 'query'> & {
    _id: string;
    _infinite?: boolean;
    tags?: ReadonlyArray<string>;
  },
];

const createQueryKey = <TOptions extends Options>(
  id: string,
  options?: TOptions,
  infinite?: boolean,
  tags?: ReadonlyArray<string>,
): [QueryKey<TOptions>[0]] => {
  const params: QueryKey<TOptions>[0] = {
    _id: id,
    baseUrl:
      options?.baseUrl || (options?.client ?? client).getConfig().baseUrl,
  } as QueryKey<TOptions>[0];
  if (infinite) {
    params._infinite = infinite;
  }
  if (tags) {
    params.tags = tags;
  }
  if (options?.body) {
    params.body = options.body;
  }
  if (options?.headers) {
    params.headers = options.headers;
  }
  if (options?.path) {
    params.path = options.path;
  }
  if (options?.query) {
    params.query = options.query;
  }
  return [params];
};

export const getCurrentAccountQueryKey = (
  options?: Options<GetCurrentAccountData>,
) => createQueryKey('getCurrentAccount', options);

/**
 * Get current account
 *
 * Get the account that owns the current token.
 *
 * This endpoint requires:
 *
 * - An account token, or
 * - A platform token with an account ID set via the `X-SavvyCal-Account` header.
 *
 */
export const getCurrentAccountOptions = (
  options?: Options<GetCurrentAccountData>,
) =>
  queryOptions<
    GetCurrentAccountResponse,
    GetCurrentAccountError,
    GetCurrentAccountResponse,
    ReturnType<typeof getCurrentAccountQueryKey>
  >({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getCurrentAccount({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getCurrentAccountQueryKey(options),
  });

export const listAccountsQueryKey = (options?: Options<ListAccountsData>) =>
  createQueryKey('listAccounts', options);

/**
 * List accounts
 *
 * List all accounts associated with the current platform (requires a platform token).
 */
export const listAccountsOptions = (options?: Options<ListAccountsData>) =>
  queryOptions<
    ListAccountsResponse,
    ListAccountsError,
    ListAccountsResponse,
    ReturnType<typeof listAccountsQueryKey>
  >({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await listAccounts({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: listAccountsQueryKey(options),
  });

const createInfiniteParams = <
  K extends Pick<QueryKey<Options>[0], 'body' | 'headers' | 'path' | 'query'>,
>(
  queryKey: QueryKey<Options>,
  page: K,
) => {
  const params = {
    ...queryKey[0],
  };
  if (page.body) {
    params.body = {
      ...(queryKey[0].body as any),
      ...(page.body as any),
    };
  }
  if (page.headers) {
    params.headers = {
      ...queryKey[0].headers,
      ...page.headers,
    };
  }
  if (page.path) {
    params.path = {
      ...(queryKey[0].path as any),
      ...(page.path as any),
    };
  }
  if (page.query) {
    params.query = {
      ...(queryKey[0].query as any),
      ...(page.query as any),
    };
  }
  return params as unknown as typeof page;
};

export const listAccountsInfiniteQueryKey = (
  options?: Options<ListAccountsData>,
): QueryKey<Options<ListAccountsData>> =>
  createQueryKey('listAccounts', options, true);

/**
 * List accounts
 *
 * List all accounts associated with the current platform (requires a platform token).
 */
export const listAccountsInfiniteOptions = (
  options?: Options<ListAccountsData>,
) => {
  return infiniteQueryOptions<
    ListAccountsResponse,
    ListAccountsError,
    InfiniteData<ListAccountsResponse>,
    QueryKey<Options<ListAccountsData>>,
    | number
    | Pick<
        QueryKey<Options<ListAccountsData>>[0],
        'body' | 'headers' | 'path' | 'query'
      >
  >(
    // @ts-ignore
    {
      queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<
          QueryKey<Options<ListAccountsData>>[0],
          'body' | 'headers' | 'path' | 'query'
        > =
          typeof pageParam === 'object'
            ? pageParam
            : {
                query: {
                  page: pageParam,
                },
              };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await listAccounts({
          ...options,
          ...params,
          signal,
          throwOnError: true,
        });
        return data;
      },
      queryKey: listAccountsInfiniteQueryKey(options),
    },
  );
};

/**
 * Create account
 *
 * Create a new account (requires a platform token).
 */
export const createAccountMutation = (
  options?: Partial<Options<CreateAccountData>>,
): UseMutationOptions<
  CreateAccountResponse,
  CreateAccountError,
  Options<CreateAccountData>
> => {
  const mutationOptions: UseMutationOptions<
    CreateAccountResponse,
    CreateAccountError,
    Options<CreateAccountData>
  > = {
    mutationFn: async (fnOptions) => {
      const { data } = await createAccount({
        ...options,
        ...fnOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const getAccountByIdQueryKey = (options: Options<GetAccountByIdData>) =>
  createQueryKey('getAccountById', options);

/**
 * Get account by ID
 *
 * Get the account by ID.
 */
export const getAccountByIdOptions = (options: Options<GetAccountByIdData>) =>
  queryOptions<
    GetAccountByIdResponse,
    GetAccountByIdError,
    GetAccountByIdResponse,
    ReturnType<typeof getAccountByIdQueryKey>
  >({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getAccountById({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getAccountByIdQueryKey(options),
  });

/**
 * Update account
 *
 * Update an existing account.
 */
export const updateAccountMutation = (
  options?: Partial<Options<UpdateAccountData>>,
): UseMutationOptions<
  UpdateAccountResponse,
  UpdateAccountError,
  Options<UpdateAccountData>
> => {
  const mutationOptions: UseMutationOptions<
    UpdateAccountResponse,
    UpdateAccountError,
    Options<UpdateAccountData>
  > = {
    mutationFn: async (fnOptions) => {
      const { data } = await updateAccount({
        ...options,
        ...fnOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const listAppointmentsQueryKey = (
  options?: Options<ListAppointmentsData>,
) => createQueryKey('listAppointments', options);

/**
 * List appointments
 *
 * List all appointments that belong to the account.
 */
export const listAppointmentsOptions = (
  options?: Options<ListAppointmentsData>,
) =>
  queryOptions<
    ListAppointmentsResponse,
    ListAppointmentsError,
    ListAppointmentsResponse,
    ReturnType<typeof listAppointmentsQueryKey>
  >({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await listAppointments({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: listAppointmentsQueryKey(options),
  });

export const listAppointmentsInfiniteQueryKey = (
  options?: Options<ListAppointmentsData>,
): QueryKey<Options<ListAppointmentsData>> =>
  createQueryKey('listAppointments', options, true);

/**
 * List appointments
 *
 * List all appointments that belong to the account.
 */
export const listAppointmentsInfiniteOptions = (
  options?: Options<ListAppointmentsData>,
) => {
  return infiniteQueryOptions<
    ListAppointmentsResponse,
    ListAppointmentsError,
    InfiniteData<ListAppointmentsResponse>,
    QueryKey<Options<ListAppointmentsData>>,
    | number
    | Pick<
        QueryKey<Options<ListAppointmentsData>>[0],
        'body' | 'headers' | 'path' | 'query'
      >
  >(
    // @ts-ignore
    {
      queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<
          QueryKey<Options<ListAppointmentsData>>[0],
          'body' | 'headers' | 'path' | 'query'
        > =
          typeof pageParam === 'object'
            ? pageParam
            : {
                query: {
                  page: pageParam,
                },
              };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await listAppointments({
          ...options,
          ...params,
          signal,
          throwOnError: true,
        });
        return data;
      },
      queryKey: listAppointmentsInfiniteQueryKey(options),
    },
  );
};

/**
 * Create appointment
 *
 * Create a new appointment. The time slot for the appointment must be available unless you explicitly disable validation (by setting `validate_slot` to `false` in the request body).
 * You can find available time slots using the [List slots for a service](/api/list-service-slots) endpoint.
 *
 */
export const createAppointmentMutation = (
  options?: Partial<Options<CreateAppointmentData>>,
): UseMutationOptions<
  CreateAppointmentResponse,
  CreateAppointmentError,
  Options<CreateAppointmentData>
> => {
  const mutationOptions: UseMutationOptions<
    CreateAppointmentResponse,
    CreateAppointmentError,
    Options<CreateAppointmentData>
  > = {
    mutationFn: async (fnOptions) => {
      const { data } = await createAppointment({
        ...options,
        ...fnOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const getAppointmentQueryKey = (options: Options<GetAppointmentData>) =>
  createQueryKey('getAppointment', options);

/**
 * Get appointment
 *
 * Get an existing appointment.
 */
export const getAppointmentOptions = (options: Options<GetAppointmentData>) =>
  queryOptions<
    GetAppointmentResponse,
    GetAppointmentError,
    GetAppointmentResponse,
    ReturnType<typeof getAppointmentQueryKey>
  >({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getAppointment({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getAppointmentQueryKey(options),
  });

/**
 * Cancel appointment
 *
 * Cancel an existing appointment.
 */
export const cancelAppointmentMutation = (
  options?: Partial<Options<CancelAppointmentData>>,
): UseMutationOptions<
  CancelAppointmentResponse,
  CancelAppointmentError,
  Options<CancelAppointmentData>
> => {
  const mutationOptions: UseMutationOptions<
    CancelAppointmentResponse,
    CancelAppointmentError,
    Options<CancelAppointmentData>
  > = {
    mutationFn: async (fnOptions) => {
      const { data } = await cancelAppointment({
        ...options,
        ...fnOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

/**
 * Confirm appointment
 *
 * Confirm an existing appointment.
 */
export const confirmAppointmentMutation = (
  options?: Partial<Options<ConfirmAppointmentData>>,
): UseMutationOptions<
  ConfirmAppointmentResponse,
  ConfirmAppointmentError,
  Options<ConfirmAppointmentData>
> => {
  const mutationOptions: UseMutationOptions<
    ConfirmAppointmentResponse,
    ConfirmAppointmentError,
    Options<ConfirmAppointmentData>
  > = {
    mutationFn: async (fnOptions) => {
      const { data } = await confirmAppointment({
        ...options,
        ...fnOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

/**
 * Reschedule appointment
 *
 * Reschedule an existing appointment. The new time slot for the appointment must be available.
 * You can find available time slots using the [List slots for a service](/api/list-service-slots) endpoint.
 *
 */
export const rescheduleAppointmentMutation = (
  options?: Partial<Options<RescheduleAppointmentData>>,
): UseMutationOptions<
  RescheduleAppointmentResponse,
  RescheduleAppointmentError,
  Options<RescheduleAppointmentData>
> => {
  const mutationOptions: UseMutationOptions<
    RescheduleAppointmentResponse,
    RescheduleAppointmentError,
    Options<RescheduleAppointmentData>
  > = {
    mutationFn: async (fnOptions) => {
      const { data } = await rescheduleAppointment({
        ...options,
        ...fnOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const listBlocksQueryKey = (options?: Options<ListBlocksData>) =>
  createQueryKey('listBlocks', options);

/**
 * List blocks
 *
 * List all blocks account-wide or attached to a specific resource type. Blocks are sorted by `start_date` in ascending order (oldest first).
 */
export const listBlocksOptions = (options?: Options<ListBlocksData>) =>
  queryOptions<
    ListBlocksResponse,
    ListBlocksError,
    ListBlocksResponse,
    ReturnType<typeof listBlocksQueryKey>
  >({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await listBlocks({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: listBlocksQueryKey(options),
  });

export const listBlocksInfiniteQueryKey = (
  options?: Options<ListBlocksData>,
): QueryKey<Options<ListBlocksData>> =>
  createQueryKey('listBlocks', options, true);

/**
 * List blocks
 *
 * List all blocks account-wide or attached to a specific resource type. Blocks are sorted by `start_date` in ascending order (oldest first).
 */
export const listBlocksInfiniteOptions = (
  options?: Options<ListBlocksData>,
) => {
  return infiniteQueryOptions<
    ListBlocksResponse,
    ListBlocksError,
    InfiniteData<ListBlocksResponse>,
    QueryKey<Options<ListBlocksData>>,
    | number
    | Pick<
        QueryKey<Options<ListBlocksData>>[0],
        'body' | 'headers' | 'path' | 'query'
      >
  >(
    // @ts-ignore
    {
      queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<
          QueryKey<Options<ListBlocksData>>[0],
          'body' | 'headers' | 'path' | 'query'
        > =
          typeof pageParam === 'object'
            ? pageParam
            : {
                query: {
                  page: pageParam,
                },
              };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await listBlocks({
          ...options,
          ...params,
          signal,
          throwOnError: true,
        });
        return data;
      },
      queryKey: listBlocksInfiniteQueryKey(options),
    },
  );
};

/**
 * Create block
 *
 * Create a new block.
 */
export const createBlockMutation = (
  options?: Partial<Options<CreateBlockData>>,
): UseMutationOptions<
  CreateBlockResponse,
  CreateBlockError,
  Options<CreateBlockData>
> => {
  const mutationOptions: UseMutationOptions<
    CreateBlockResponse,
    CreateBlockError,
    Options<CreateBlockData>
  > = {
    mutationFn: async (fnOptions) => {
      const { data } = await createBlock({
        ...options,
        ...fnOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

/**
 * Delete block
 *
 * Delete an existing block.
 */
export const deleteBlockMutation = (
  options?: Partial<Options<DeleteBlockData>>,
): UseMutationOptions<
  DeleteBlockResponse,
  DeleteBlockError,
  Options<DeleteBlockData>
> => {
  const mutationOptions: UseMutationOptions<
    DeleteBlockResponse,
    DeleteBlockError,
    Options<DeleteBlockData>
  > = {
    mutationFn: async (fnOptions) => {
      const { data } = await deleteBlock({
        ...options,
        ...fnOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const getBlockQueryKey = (options: Options<GetBlockData>) =>
  createQueryKey('getBlock', options);

/**
 * Get block
 *
 * Get a block by ID.
 */
export const getBlockOptions = (options: Options<GetBlockData>) =>
  queryOptions<
    GetBlockResponse,
    GetBlockError,
    GetBlockResponse,
    ReturnType<typeof getBlockQueryKey>
  >({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getBlock({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getBlockQueryKey(options),
  });

/**
 * Update block
 *
 * Update an existing block.
 */
export const updateBlockMutation = (
  options?: Partial<Options<UpdateBlockData>>,
): UseMutationOptions<
  UpdateBlockResponse,
  UpdateBlockError,
  Options<UpdateBlockData>
> => {
  const mutationOptions: UseMutationOptions<
    UpdateBlockResponse,
    UpdateBlockError,
    Options<UpdateBlockData>
  > = {
    mutationFn: async (fnOptions) => {
      const { data } = await updateBlock({
        ...options,
        ...fnOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const listCancellationReasonsQueryKey = (
  options?: Options<ListCancellationReasonsData>,
) => createQueryKey('listCancellationReasons', options);

/**
 * List cancellation reasons
 *
 * List all cancellation reasons for an account
 */
export const listCancellationReasonsOptions = (
  options?: Options<ListCancellationReasonsData>,
) =>
  queryOptions<
    ListCancellationReasonsResponse,
    ListCancellationReasonsError,
    ListCancellationReasonsResponse,
    ReturnType<typeof listCancellationReasonsQueryKey>
  >({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await listCancellationReasons({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: listCancellationReasonsQueryKey(options),
  });

/**
 * Create cancellation reason
 *
 * Create a new cancellation reason in the account.
 */
export const createCancellationReasonMutation = (
  options?: Partial<Options<CreateCancellationReasonData>>,
): UseMutationOptions<
  CreateCancellationReasonResponse,
  CreateCancellationReasonError,
  Options<CreateCancellationReasonData>
> => {
  const mutationOptions: UseMutationOptions<
    CreateCancellationReasonResponse,
    CreateCancellationReasonError,
    Options<CreateCancellationReasonData>
  > = {
    mutationFn: async (fnOptions) => {
      const { data } = await createCancellationReason({
        ...options,
        ...fnOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

/**
 * Delete cancellation reason
 *
 * Delete an existing cancellation reason.
 */
export const deleteCancellationReasonMutation = (
  options?: Partial<Options<DeleteCancellationReasonData>>,
): UseMutationOptions<
  DeleteCancellationReasonResponse,
  DeleteCancellationReasonError,
  Options<DeleteCancellationReasonData>
> => {
  const mutationOptions: UseMutationOptions<
    DeleteCancellationReasonResponse,
    DeleteCancellationReasonError,
    Options<DeleteCancellationReasonData>
  > = {
    mutationFn: async (fnOptions) => {
      const { data } = await deleteCancellationReason({
        ...options,
        ...fnOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const getCancellationReasonQueryKey = (
  options: Options<GetCancellationReasonData>,
) => createQueryKey('getCancellationReason', options);

/**
 * Get cancellation reason
 *
 * Get a single cancellation reason by ID.
 */
export const getCancellationReasonOptions = (
  options: Options<GetCancellationReasonData>,
) =>
  queryOptions<
    GetCancellationReasonResponse,
    GetCancellationReasonError,
    GetCancellationReasonResponse,
    ReturnType<typeof getCancellationReasonQueryKey>
  >({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getCancellationReason({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getCancellationReasonQueryKey(options),
  });

/**
 * Update cancellation reason
 *
 * Update an existing cancellation reason.
 */
export const updateCancellationReasonMutation = (
  options?: Partial<Options<UpdateCancellationReasonData>>,
): UseMutationOptions<
  UpdateCancellationReasonResponse,
  UpdateCancellationReasonError,
  Options<UpdateCancellationReasonData>
> => {
  const mutationOptions: UseMutationOptions<
    UpdateCancellationReasonResponse,
    UpdateCancellationReasonError,
    Options<UpdateCancellationReasonData>
  > = {
    mutationFn: async (fnOptions) => {
      const { data } = await updateCancellationReason({
        ...options,
        ...fnOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const listClientsQueryKey = (options?: Options<ListClientsData>) =>
  createQueryKey('listClients', options);

/**
 * List clients
 *
 * List all clients that belong to the account.
 */
export const listClientsOptions = (options?: Options<ListClientsData>) =>
  queryOptions<
    ListClientsResponse,
    ListClientsError,
    ListClientsResponse,
    ReturnType<typeof listClientsQueryKey>
  >({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await listClients({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: listClientsQueryKey(options),
  });

export const listClientsInfiniteQueryKey = (
  options?: Options<ListClientsData>,
): QueryKey<Options<ListClientsData>> =>
  createQueryKey('listClients', options, true);

/**
 * List clients
 *
 * List all clients that belong to the account.
 */
export const listClientsInfiniteOptions = (
  options?: Options<ListClientsData>,
) => {
  return infiniteQueryOptions<
    ListClientsResponse,
    ListClientsError,
    InfiniteData<ListClientsResponse>,
    QueryKey<Options<ListClientsData>>,
    | number
    | Pick<
        QueryKey<Options<ListClientsData>>[0],
        'body' | 'headers' | 'path' | 'query'
      >
  >(
    // @ts-ignore
    {
      queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<
          QueryKey<Options<ListClientsData>>[0],
          'body' | 'headers' | 'path' | 'query'
        > =
          typeof pageParam === 'object'
            ? pageParam
            : {
                query: {
                  page: pageParam,
                },
              };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await listClients({
          ...options,
          ...params,
          signal,
          throwOnError: true,
        });
        return data;
      },
      queryKey: listClientsInfiniteQueryKey(options),
    },
  );
};

/**
 * Create client
 *
 * Create a new client in the account.
 */
export const createClientMutation = (
  options?: Partial<Options<CreateClientData>>,
): UseMutationOptions<
  CreateClientResponse,
  CreateClientError,
  Options<CreateClientData>
> => {
  const mutationOptions: UseMutationOptions<
    CreateClientResponse,
    CreateClientError,
    Options<CreateClientData>
  > = {
    mutationFn: async (fnOptions) => {
      const { data } = await createClient({
        ...options,
        ...fnOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

/**
 * Delete client
 *
 * Deletes an existing client.
 */
export const deleteClientMutation = (
  options?: Partial<Options<DeleteClientData>>,
): UseMutationOptions<
  DeleteClientResponse,
  DeleteClientError,
  Options<DeleteClientData>
> => {
  const mutationOptions: UseMutationOptions<
    DeleteClientResponse,
    DeleteClientError,
    Options<DeleteClientData>
  > = {
    mutationFn: async (fnOptions) => {
      const { data } = await deleteClient({
        ...options,
        ...fnOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const getClientQueryKey = (options: Options<GetClientData>) =>
  createQueryKey('getClient', options);

/**
 * Get client
 *
 * Get a single client by ID.
 */
export const getClientOptions = (options: Options<GetClientData>) =>
  queryOptions<
    GetClientResponse,
    GetClientError,
    GetClientResponse,
    ReturnType<typeof getClientQueryKey>
  >({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getClient({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getClientQueryKey(options),
  });

/**
 * Update client
 *
 * Update an existing client.
 */
export const updateClientMutation = (
  options?: Partial<Options<UpdateClientData>>,
): UseMutationOptions<
  UpdateClientResponse,
  UpdateClientError,
  Options<UpdateClientData>
> => {
  const mutationOptions: UseMutationOptions<
    UpdateClientResponse,
    UpdateClientError,
    Options<UpdateClientData>
  > = {
    mutationFn: async (fnOptions) => {
      const { data } = await updateClient({
        ...options,
        ...fnOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

/**
 * Create dashboard session
 *
 * The Dashboard Sessions API allows you to generate a short-lived session link
 * that grants an account member access to the dashboard without requiring login credentials.
 * This is useful for creating seamless, secure login experiences from external systems or integrations.
 *
 * Before you can generate a session link for someone, you'll need to add them to your SavvyCal account.
 * You can do this by navigating to [Settings → Members & permissions](https://savvycal.app/users)
 * and following the instructions to add a new user. Alternatively, you may use the
 * [Create account user API](https://developers.savvycal.app/api/create-account-user) to add them
 * programmatically.
 *
 * The `user_id` property property can be retrieved from the [List account users API](https://developers.savvycal.app/api/list-account-users),
 * or by copying it directly from the [Settings → Members & permissions](https://savvycal.app/users) page.
 *
 * To sign the user in, redirect the browser to the dashboard session `url` returned in the response.
 *
 * ## Example Flow
 *
 * 1. User clicks a button in your application to "Manage appointments".
 * 2. Your application receives this request and creates a dashboard session via the API.
 * 3. Your application redirects the user to the dashboard session URL.
 * 4. The user is automatically signed in to the dashboard and redirected to the home screen.
 *
 */
export const createDashboardSessionMutation = (
  options?: Partial<Options<CreateDashboardSessionData>>,
): UseMutationOptions<
  CreateDashboardSessionResponse,
  CreateDashboardSessionError,
  Options<CreateDashboardSessionData>
> => {
  const mutationOptions: UseMutationOptions<
    CreateDashboardSessionResponse,
    CreateDashboardSessionError,
    Options<CreateDashboardSessionData>
  > = {
    mutationFn: async (fnOptions) => {
      const { data } = await createDashboardSession({
        ...options,
        ...fnOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const getCurrentPlatformQueryKey = (
  options?: Options<GetCurrentPlatformData>,
) => createQueryKey('getCurrentPlatform', options);

/**
 * Get current platform
 *
 * Get the platform that owns the current token (requires a platform token).
 *
 */
export const getCurrentPlatformOptions = (
  options?: Options<GetCurrentPlatformData>,
) =>
  queryOptions<
    GetCurrentPlatformResponse,
    GetCurrentPlatformError,
    GetCurrentPlatformResponse,
    ReturnType<typeof getCurrentPlatformQueryKey>
  >({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getCurrentPlatform({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getCurrentPlatformQueryKey(options),
  });

export const listProviderSchedulesQueryKey = (
  options?: Options<ListProviderSchedulesData>,
) => createQueryKey('listProviderSchedules', options);

/**
 * List provider schedules
 *
 * List all provider schedules account-wide or for a specific provider.
 */
export const listProviderSchedulesOptions = (
  options?: Options<ListProviderSchedulesData>,
) =>
  queryOptions<
    ListProviderSchedulesResponse,
    ListProviderSchedulesError,
    ListProviderSchedulesResponse,
    ReturnType<typeof listProviderSchedulesQueryKey>
  >({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await listProviderSchedules({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: listProviderSchedulesQueryKey(options),
  });

export const listProviderSchedulesInfiniteQueryKey = (
  options?: Options<ListProviderSchedulesData>,
): QueryKey<Options<ListProviderSchedulesData>> =>
  createQueryKey('listProviderSchedules', options, true);

/**
 * List provider schedules
 *
 * List all provider schedules account-wide or for a specific provider.
 */
export const listProviderSchedulesInfiniteOptions = (
  options?: Options<ListProviderSchedulesData>,
) => {
  return infiniteQueryOptions<
    ListProviderSchedulesResponse,
    ListProviderSchedulesError,
    InfiniteData<ListProviderSchedulesResponse>,
    QueryKey<Options<ListProviderSchedulesData>>,
    | number
    | Pick<
        QueryKey<Options<ListProviderSchedulesData>>[0],
        'body' | 'headers' | 'path' | 'query'
      >
  >(
    // @ts-ignore
    {
      queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<
          QueryKey<Options<ListProviderSchedulesData>>[0],
          'body' | 'headers' | 'path' | 'query'
        > =
          typeof pageParam === 'object'
            ? pageParam
            : {
                query: {
                  page: pageParam,
                },
              };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await listProviderSchedules({
          ...options,
          ...params,
          signal,
          throwOnError: true,
        });
        return data;
      },
      queryKey: listProviderSchedulesInfiniteQueryKey(options),
    },
  );
};

/**
 * Delete provider schedule
 *
 * Delete an existing provider schedule.
 */
export const deleteProviderScheduleMutation = (
  options?: Partial<Options<DeleteProviderScheduleData>>,
): UseMutationOptions<
  DeleteProviderScheduleResponse,
  DeleteProviderScheduleError,
  Options<DeleteProviderScheduleData>
> => {
  const mutationOptions: UseMutationOptions<
    DeleteProviderScheduleResponse,
    DeleteProviderScheduleError,
    Options<DeleteProviderScheduleData>
  > = {
    mutationFn: async (fnOptions) => {
      const { data } = await deleteProviderSchedule({
        ...options,
        ...fnOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const getProviderScheduleQueryKey = (
  options: Options<GetProviderScheduleData>,
) => createQueryKey('getProviderSchedule', options);

/**
 * Get provider schedule
 *
 * Get a provider schedule by ID.
 */
export const getProviderScheduleOptions = (
  options: Options<GetProviderScheduleData>,
) =>
  queryOptions<
    GetProviderScheduleResponse,
    GetProviderScheduleError,
    GetProviderScheduleResponse,
    ReturnType<typeof getProviderScheduleQueryKey>
  >({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getProviderSchedule({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getProviderScheduleQueryKey(options),
  });

/**
 * Update provider schedule
 *
 * Update an existing provider schedule.
 */
export const updateProviderScheduleMutation = (
  options?: Partial<Options<UpdateProviderScheduleData>>,
): UseMutationOptions<
  UpdateProviderScheduleResponse,
  UpdateProviderScheduleError,
  Options<UpdateProviderScheduleData>
> => {
  const mutationOptions: UseMutationOptions<
    UpdateProviderScheduleResponse,
    UpdateProviderScheduleError,
    Options<UpdateProviderScheduleData>
  > = {
    mutationFn: async (fnOptions) => {
      const { data } = await updateProviderSchedule({
        ...options,
        ...fnOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const listProvidersQueryKey = (options?: Options<ListProvidersData>) =>
  createQueryKey('listProviders', options);

/**
 * List providers
 *
 * List all providers that belong to the account.
 */
export const listProvidersOptions = (options?: Options<ListProvidersData>) =>
  queryOptions<
    ListProvidersResponse,
    ListProvidersError,
    ListProvidersResponse,
    ReturnType<typeof listProvidersQueryKey>
  >({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await listProviders({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: listProvidersQueryKey(options),
  });

export const listProvidersInfiniteQueryKey = (
  options?: Options<ListProvidersData>,
): QueryKey<Options<ListProvidersData>> =>
  createQueryKey('listProviders', options, true);

/**
 * List providers
 *
 * List all providers that belong to the account.
 */
export const listProvidersInfiniteOptions = (
  options?: Options<ListProvidersData>,
) => {
  return infiniteQueryOptions<
    ListProvidersResponse,
    ListProvidersError,
    InfiniteData<ListProvidersResponse>,
    QueryKey<Options<ListProvidersData>>,
    | number
    | Pick<
        QueryKey<Options<ListProvidersData>>[0],
        'body' | 'headers' | 'path' | 'query'
      >
  >(
    // @ts-ignore
    {
      queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<
          QueryKey<Options<ListProvidersData>>[0],
          'body' | 'headers' | 'path' | 'query'
        > =
          typeof pageParam === 'object'
            ? pageParam
            : {
                query: {
                  page: pageParam,
                },
              };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await listProviders({
          ...options,
          ...params,
          signal,
          throwOnError: true,
        });
        return data;
      },
      queryKey: listProvidersInfiniteQueryKey(options),
    },
  );
};

/**
 * Create provider
 *
 * Create a new provider in the account.
 */
export const createProviderMutation = (
  options?: Partial<Options<CreateProviderData>>,
): UseMutationOptions<
  CreateProviderResponse,
  CreateProviderError,
  Options<CreateProviderData>
> => {
  const mutationOptions: UseMutationOptions<
    CreateProviderResponse,
    CreateProviderError,
    Options<CreateProviderData>
  > = {
    mutationFn: async (fnOptions) => {
      const { data } = await createProvider({
        ...options,
        ...fnOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

/**
 * Deactivate provider
 *
 * Deactivates an existing provider.
 */
export const deactivateProviderMutation = (
  options?: Partial<Options<DeactivateProviderData>>,
): UseMutationOptions<
  DeactivateProviderResponse,
  DeactivateProviderError,
  Options<DeactivateProviderData>
> => {
  const mutationOptions: UseMutationOptions<
    DeactivateProviderResponse,
    DeactivateProviderError,
    Options<DeactivateProviderData>
  > = {
    mutationFn: async (fnOptions) => {
      const { data } = await deactivateProvider({
        ...options,
        ...fnOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const getProviderQueryKey = (options: Options<GetProviderData>) =>
  createQueryKey('getProvider', options);

/**
 * Get provider
 *
 * Get a single provider by ID.
 */
export const getProviderOptions = (options: Options<GetProviderData>) =>
  queryOptions<
    GetProviderResponse,
    GetProviderError,
    GetProviderResponse,
    ReturnType<typeof getProviderQueryKey>
  >({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getProvider({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getProviderQueryKey(options),
  });

/**
 * Update provider
 *
 * Update an existing provider.
 */
export const updateProviderMutation = (
  options?: Partial<Options<UpdateProviderData>>,
): UseMutationOptions<
  UpdateProviderResponse,
  UpdateProviderError,
  Options<UpdateProviderData>
> => {
  const mutationOptions: UseMutationOptions<
    UpdateProviderResponse,
    UpdateProviderError,
    Options<UpdateProviderData>
  > = {
    mutationFn: async (fnOptions) => {
      const { data } = await updateProvider({
        ...options,
        ...fnOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

/**
 * Create provider schedule
 *
 * Create a new provider schedule.
 */
export const createProviderScheduleMutation = (
  options?: Partial<Options<CreateProviderScheduleData>>,
): UseMutationOptions<
  CreateProviderScheduleResponse,
  CreateProviderScheduleError,
  Options<CreateProviderScheduleData>
> => {
  const mutationOptions: UseMutationOptions<
    CreateProviderScheduleResponse,
    CreateProviderScheduleError,
    Options<CreateProviderScheduleData>
  > = {
    mutationFn: async (fnOptions) => {
      const { data } = await createProviderSchedule({
        ...options,
        ...fnOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const listRolesQueryKey = (options?: Options<ListRolesData>) =>
  createQueryKey('listRoles', options);

/**
 * List roles
 *
 * List all roles that belong to the specified account.
 */
export const listRolesOptions = (options?: Options<ListRolesData>) =>
  queryOptions<
    ListRolesResponse,
    ListRolesError,
    ListRolesResponse,
    ReturnType<typeof listRolesQueryKey>
  >({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await listRoles({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: listRolesQueryKey(options),
  });

/**
 * Remove service provider
 *
 * Remove a provider from a service
 */
export const deleteServiceProviderMutation = (
  options?: Partial<Options<DeleteServiceProviderData>>,
): UseMutationOptions<
  DeleteServiceProviderResponse,
  DeleteServiceProviderError,
  Options<DeleteServiceProviderData>
> => {
  const mutationOptions: UseMutationOptions<
    DeleteServiceProviderResponse,
    DeleteServiceProviderError,
    Options<DeleteServiceProviderData>
  > = {
    mutationFn: async (fnOptions) => {
      const { data } = await deleteServiceProvider({
        ...options,
        ...fnOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const listServicesQueryKey = (options?: Options<ListServicesData>) =>
  createQueryKey('listServices', options);

/**
 * List services
 *
 * List all services for an account
 */
export const listServicesOptions = (options?: Options<ListServicesData>) =>
  queryOptions<
    ListServicesResponse,
    ListServicesError,
    ListServicesResponse,
    ReturnType<typeof listServicesQueryKey>
  >({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await listServices({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: listServicesQueryKey(options),
  });

export const listServicesInfiniteQueryKey = (
  options?: Options<ListServicesData>,
): QueryKey<Options<ListServicesData>> =>
  createQueryKey('listServices', options, true);

/**
 * List services
 *
 * List all services for an account
 */
export const listServicesInfiniteOptions = (
  options?: Options<ListServicesData>,
) => {
  return infiniteQueryOptions<
    ListServicesResponse,
    ListServicesError,
    InfiniteData<ListServicesResponse>,
    QueryKey<Options<ListServicesData>>,
    | number
    | Pick<
        QueryKey<Options<ListServicesData>>[0],
        'body' | 'headers' | 'path' | 'query'
      >
  >(
    // @ts-ignore
    {
      queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<
          QueryKey<Options<ListServicesData>>[0],
          'body' | 'headers' | 'path' | 'query'
        > =
          typeof pageParam === 'object'
            ? pageParam
            : {
                query: {
                  page: pageParam,
                },
              };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await listServices({
          ...options,
          ...params,
          signal,
          throwOnError: true,
        });
        return data;
      },
      queryKey: listServicesInfiniteQueryKey(options),
    },
  );
};

/**
 * Create service
 *
 * Create a new service in the account.
 */
export const createServiceMutation = (
  options?: Partial<Options<CreateServiceData>>,
): UseMutationOptions<
  CreateServiceResponse,
  CreateServiceError,
  Options<CreateServiceData>
> => {
  const mutationOptions: UseMutationOptions<
    CreateServiceResponse,
    CreateServiceError,
    Options<CreateServiceData>
  > = {
    mutationFn: async (fnOptions) => {
      const { data } = await createService({
        ...options,
        ...fnOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

/**
 * Delete service
 *
 * Delete an existing service.
 */
export const deleteServiceMutation = (
  options?: Partial<Options<DeleteServiceData>>,
): UseMutationOptions<
  DeleteServiceResponse,
  DeleteServiceError,
  Options<DeleteServiceData>
> => {
  const mutationOptions: UseMutationOptions<
    DeleteServiceResponse,
    DeleteServiceError,
    Options<DeleteServiceData>
  > = {
    mutationFn: async (fnOptions) => {
      const { data } = await deleteService({
        ...options,
        ...fnOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const getServiceQueryKey = (options: Options<GetServiceData>) =>
  createQueryKey('getService', options);

/**
 * Get service
 *
 * Get a single service by ID.
 */
export const getServiceOptions = (options: Options<GetServiceData>) =>
  queryOptions<
    GetServiceResponse,
    GetServiceError,
    GetServiceResponse,
    ReturnType<typeof getServiceQueryKey>
  >({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getService({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getServiceQueryKey(options),
  });

/**
 * Update service
 *
 * Update an existing service.
 */
export const updateServiceMutation = (
  options?: Partial<Options<UpdateServiceData>>,
): UseMutationOptions<
  UpdateServiceResponse,
  UpdateServiceError,
  Options<UpdateServiceData>
> => {
  const mutationOptions: UseMutationOptions<
    UpdateServiceResponse,
    UpdateServiceError,
    Options<UpdateServiceData>
  > = {
    mutationFn: async (fnOptions) => {
      const { data } = await updateService({
        ...options,
        ...fnOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const listServiceProvidersQueryKey = (
  options: Options<ListServiceProvidersData>,
) => createQueryKey('listServiceProviders', options);

/**
 * List service providers
 *
 * List all providers associated with a service
 */
export const listServiceProvidersOptions = (
  options: Options<ListServiceProvidersData>,
) =>
  queryOptions<
    ListServiceProvidersResponse,
    ListServiceProvidersError,
    ListServiceProvidersResponse,
    ReturnType<typeof listServiceProvidersQueryKey>
  >({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await listServiceProviders({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: listServiceProvidersQueryKey(options),
  });

/**
 * Add provider to service
 *
 * Associate a provider with a service
 */
export const createServiceProviderMutation = (
  options?: Partial<Options<CreateServiceProviderData>>,
): UseMutationOptions<
  CreateServiceProviderResponse,
  CreateServiceProviderError,
  Options<CreateServiceProviderData>
> => {
  const mutationOptions: UseMutationOptions<
    CreateServiceProviderResponse,
    CreateServiceProviderError,
    Options<CreateServiceProviderData>
  > = {
    mutationFn: async (fnOptions) => {
      const { data } = await createServiceProvider({
        ...options,
        ...fnOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const listServiceSlotsQueryKey = (
  options: Options<ListServiceSlotsData>,
) => createQueryKey('listServiceSlots', options);

/**
 * List slots for a service
 *
 * List all available slots for a service in a specific time range
 */
export const listServiceSlotsOptions = (
  options: Options<ListServiceSlotsData>,
) =>
  queryOptions<
    ListServiceSlotsResponse,
    ListServiceSlotsError,
    ListServiceSlotsResponse,
    ReturnType<typeof listServiceSlotsQueryKey>
  >({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await listServiceSlots({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: listServiceSlotsQueryKey(options),
  });

export const listAccountUsersQueryKey = (
  options?: Options<ListAccountUsersData>,
) => createQueryKey('listAccountUsers', options);

/**
 * List account users
 *
 * List all users that belong to the specified account.
 */
export const listAccountUsersOptions = (
  options?: Options<ListAccountUsersData>,
) =>
  queryOptions<
    ListAccountUsersResponse,
    ListAccountUsersError,
    ListAccountUsersResponse,
    ReturnType<typeof listAccountUsersQueryKey>
  >({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await listAccountUsers({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: listAccountUsersQueryKey(options),
  });

/**
 * Create account user
 *
 * Create a new user in the specified account.
 */
export const createAccountUserMutation = (
  options?: Partial<Options<CreateAccountUserData>>,
): UseMutationOptions<
  CreateAccountUserResponse,
  CreateAccountUserError,
  Options<CreateAccountUserData>
> => {
  const mutationOptions: UseMutationOptions<
    CreateAccountUserResponse,
    CreateAccountUserError,
    Options<CreateAccountUserData>
  > = {
    mutationFn: async (fnOptions) => {
      const { data } = await createAccountUser({
        ...options,
        ...fnOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};
