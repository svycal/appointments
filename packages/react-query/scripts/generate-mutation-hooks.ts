import { execSync } from "child_process";
import { mkdirSync, readFileSync, writeFileSync } from "fs";
import { dirname, join } from "path";
import { fileURLToPath } from "url";

const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);

type HttpMethod = "delete" | "get" | "patch" | "post" | "put";

interface OperationInfo {
  fileName: string;
  hookName: string;
  method: HttpMethod;
  operationName: string;
  path: string;
}

// Helper to convert camelCase to kebab-case
function camelToKebab(str: string): string {
  return str.replace(/([a-z0-9])([A-Z])/g, "$1-$2").toLowerCase();
}

// Extract all non-GET operations from the schema (POST, PUT, PATCH, DELETE)
function extractMutationOperations(): OperationInfo[] {
  const operations: OperationInfo[] = [];

  // We need to parse the schema type at runtime
  // Since we can't introspect types at runtime, we'll read the schema.d.ts file
  const schemaPath = join(__dirname, "../../core/src/schema.d.ts");
  const schemaContent = readFileSync(schemaPath, "utf-8");

  // Extract each path block and its mutation operations
  // Split by path definitions and process each one
  const pathBlockRegex = /"([^"]+\/[^"]*)":\s*\{([\s\S]*?)(?=\n {2}"\/|$)/g;
  let pathMatch;

  while ((pathMatch = pathBlockRegex.exec(schemaContent)) !== null) {
    const [, path, blockContent] = pathMatch;

    // Check for POST, PUT, PATCH, DELETE operations
    const methods: Array<{ method: HttpMethod; regex: RegExp }> = [
      { method: "post", regex: /post:\s*operations\["([^"]+)"\]/ },
      { method: "put", regex: /put:\s*operations\["([^"]+)"\]/ },
      { method: "patch", regex: /patch:\s*operations\["([^"]+)"\]/ },
      { method: "delete", regex: /delete:\s*operations\["([^"]+)"\]/ },
    ];

    for (const { method, regex } of methods) {
      const opMatch = blockContent.match(regex);
      if (!opMatch) continue;

      const operationName = opMatch[1];
      const hookName = operationToHookName(operationName);
      const fileName = camelToKebab(hookName);

      operations.push({
        fileName,
        hookName,
        method,
        operationName,
        path,
      });
    }
  }

  return operations;
}

// Generate barrel export file
function generateBarrelExport(operations: OperationInfo[]): string {
  const lines: string[] = [];

  // Sort operations alphabetically by hook name
  const sorted = [...operations].sort((a, b) =>
    a.hookName.localeCompare(b.hookName),
  );

  lines.push("/**");
  lines.push(
    " * This file was auto-generated by scripts/generate-mutation-hooks.ts",
  );
  lines.push(" * Do not make direct changes to the file.");
  lines.push(" */");
  lines.push("");

  for (const op of sorted) {
    lines.push(
      `export { ${op.hookName} } from './mutation-hooks/${op.fileName}';`,
    );
  }

  lines.push("");

  return lines.join("\n");
}

// Generate hook file content
function generateHookFile(op: OperationInfo): string {
  const lines: string[] = [
    `/**`,
    ` * This file was auto-generated by scripts/generate-mutation-hooks.ts`,
    ` * Do not make direct changes to the file.`,
    ` */`,
    ``,
    `import { useSavvyCalQueryClient } from '../provider';`,
    `import type { QueryClient, MutationOptionsFor } from '../client';`,
    ``,
    `interface Options extends MutationOptionsFor<'${op.method}', '${op.path}'> {`,
    `  client?: QueryClient;`,
    `}`,
    ``,
    `export const ${op.hookName} = (options?: Options) => {`,
    `  const { client: overrideClient, ...mutationOptions } = options ?? {};`,
    `  const client = useSavvyCalQueryClient(overrideClient);`,
    ``,
    `  return client.useMutation('${op.method}', '${op.path}', mutationOptions);`,
    `};`,
    ``,
  ];

  return lines.join("\n");
}

// Main function
async function main() {
  console.log("üîç Extracting mutation operations from schema...");
  const operations = extractMutationOperations();

  console.log(`üìù Found ${operations.length} mutation operations`);

  // Create mutation hooks directory if it doesn't exist
  const hooksDir = join(__dirname, "../src/mutation-hooks");
  mkdirSync(hooksDir, { recursive: true });

  // Generate each hook file
  console.log("‚ú® Generating mutation hook files...");
  for (const op of operations) {
    const content = generateHookFile(op);
    const filePath = join(hooksDir, `${op.fileName}.ts`);
    writeFileSync(filePath, content, "utf-8");
    console.log(`  ‚úì ${op.fileName}.ts`);
  }

  // Generate barrel export
  console.log("üì¶ Generating barrel export...");
  const barrelContent = generateBarrelExport(operations);
  const barrelPath = join(__dirname, "../src/mutation-hooks.ts");
  writeFileSync(barrelPath, barrelContent, "utf-8");
  console.log(`  ‚úì mutation-hooks.ts`);

  // Format generated files with eslint
  console.log("\nüé® Formatting generated files with eslint...");
  execSync(
    'pnpm eslint --fix "src/mutation-hooks/**/*.ts" "src/mutation-hooks.ts"',
    {
      cwd: join(__dirname, ".."),
      stdio: "inherit",
    },
  );

  console.log(`\n‚úÖ Successfully generated ${operations.length} hooks!`);
}

// Helper to convert operation name to hook name
function operationToHookName(operationName: string): string {
  // For mutations, we want to preserve certain prefixes and convert others

  // Handle DELETE operations
  if (
    operationName.startsWith("delete") ||
    operationName.startsWith("deactivate")
  ) {
    return `use${operationName.charAt(0).toUpperCase()}${operationName.slice(1)}`;
  }

  // Handle UPDATE/PATCH operations
  if (operationName.startsWith("update")) {
    return `use${operationName.charAt(0).toUpperCase()}${operationName.slice(1)}`;
  }

  // Handle CREATE/POST operations
  if (operationName.startsWith("create")) {
    return `use${operationName.charAt(0).toUpperCase()}${operationName.slice(1)}`;
  }

  // For other operations (confirm, cancel, reschedule, etc.), preserve the prefix
  return `use${operationName.charAt(0).toUpperCase()}${operationName.slice(1)}`;
}

main().catch(console.error);
